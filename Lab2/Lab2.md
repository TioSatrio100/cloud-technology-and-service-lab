# Лабораторная работа №2

# Ход работы
## 1. Плохой Dockerfile (bad.Dockerfile)
```bash
FROM ubuntu:20.04

RUN apt-get update
RUN apt-get install -y python3
RUN apt-get install -y python3-pip

COPY . /app

WORKDIR /app

CMD python3 app.py
```
## 2. Хороший Dockerfile (good.Dockerfile)
```bash
FROM ubuntu:20.04

COPY app.py .

RUN apt-get update && \
    apt-get install -y python3 && \
    apt-get install -y python3-pip

RUN groupadd -r appuser && useradd -r -g appuser appuser

USER appuser

CMD ["python3", "app.py"]
```
## 3. Файл app.py
```bash
print("Hello!")
```

## 4. Плохие практики в bad.Dockerfile
| № | Плохая практика | Почему плохо | Как исправлено | Результат |
|---|------------------|---------------|----------------|--------|
| 1 | Множественные `RUN` команды для установки пакетов |- Каждая команда RUN создает отдельный слой в образе<br/> - Не очищается кэш apt-get, что увеличивает размер образа<br/> - Установка ненужных пакетов (python3-pip для простого print) | Объединение команд сокращает число слоев, что уменьшает итоговый размер образа. | - Минимизация количества слоев Docker образа<br/> - Значительное уменьшение размера конечного образа |
| 2 | Копирование всего контекста без разбора (`COPY . /app`) | - Копируются все файлы из контекста сборки, включая временные и системные файлы<br/>- Нет использования .dockerignore для исключения ненужных файлов<br/> - При любом изменении в любой файле инвалидируется кэш Docker|  Копируется только `COPY app.py .` | - Уменьшение размера контекста сборки <br/> - Более быстрая сборка образов<br/> - Лучшее использование кэша Docker|
| 3 | Отсутствие пользовательской безопасности | - Повышение привилегий создает угрозу безопасности<br/> - При компрометации контейнера атакующий получает root-доступ<br/> - Нарушает принцип минимальных привилегий | - Создается отдельный непривилегированный пользователь<br/>- Приложение запускается с минимальными правами | - Повышение безопасности контейнера<br/> - Соответствие best practices безопасности |
## 5. Запуск проекта
```bash
sudo docker build -t docker-bad-app -f bad.Dockerfile .
sudo docker run docker-bad-app
```
### Результат:
![1](https://github.com/TioSatrio100/cloud-technology-and-service-lab/blob/main/Lab2/build-bad.png)

![1](https://github.com/TioSatrio100/cloud-technology-and-service-lab/blob/main/Lab2/run-bad.png)
```bash
sudo docker build -t docker-good-app -f good.Dockerfile .
sudo docker run docker-good-app
```
### Результат:
![1](https://github.com/TioSatrio100/cloud-technology-and-service-lab/blob/main/Lab2/build-good.png)

![1](https://github.com/TioSatrio100/cloud-technology-and-service-lab/blob/main/Lab2/run-good.png)

## 6. Плохие практики при работе с контейнерами
### Запуск контейнеров с неограниченными ресурсами

**Почему это плохо:**

- Один контейнер может "задушить" всю систему

- Невозможно предсказать поведение системы под нагрузкой

- Проблемы с стабильностью в production среде

### Игнорирование логов и мониторинга

**Почему это плохо:**

- Потеря важной информации при авариях

- Невозможность диагностировать проблемы

- Отсутствие понимания работы приложения в production

# Вывод
- В этой лабораторной работе показано, как выбор базового образа, порядок инструкций и настройка окружения
влияет на размер, безопасность и удобство использования контейнера.
- В результате работы были получены практические навыки по оптимизации Dockerfile и осознание важности
соблюдения принципов минимализма, безопасности и воспроизводимости при создании контейнеров.
